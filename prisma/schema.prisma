generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Player model - tracks unique players across games
model Player {
  id        String   @id @default(uuid())
visitorId String?  @unique // Browser fingerprint for anonymous players
  name      String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  gamesHosted    Game[]       @relation("GameHost")
  gameSessions   GamePlayer[]
  cluesGiven     GameClue[]
  votesSubmitted GameVote[]   @relation("VoteCaster")
  votesReceived  GameVote[]   @relation("VoteTarget")

  @@index([visitorId])
}

// Game model - represents a completed or ongoing game
model Game {
  id           String     @id @default(uuid())
  code         String     @unique // 4-letter lobby code
  gameType     String     @default("undercover") // For future game types
  status       GameStatus @default(WAITING)
  category     String?
  secretWord   String?
  chameleonId  String? // ID of the player who was the chameleon

  // Results
  chameleonCaught       Boolean?
  chameleonGuess        String?
  chameleonGuessCorrect Boolean?
  winningSide           String? // "chameleon" or "players"

  // Timestamps
  createdAt DateTime  @default(now())
  startedAt DateTime?
  endedAt   DateTime?
  updatedAt DateTime  @updatedAt

  // Relations
  hostId  String
  host    Player       @relation("GameHost", fields: [hostId], references: [id])
  players GamePlayer[]
  clues   GameClue[]
  votes   GameVote[]
  events  GameEvent[]

  @@index([code])
  @@index([status])
  @@index([createdAt])
}

// GamePlayer - join table for players in a game
model GamePlayer {
  id       String  @id @default(uuid())
  gameId   String
  playerId String

  // In-game state
  displayName   String // Name used in this game
  isHost        Boolean @default(false)
  isChameleon   Boolean @default(false)
  turnOrder     Int?
  isConnected   Boolean @default(true)

  joinedAt      DateTime @default(now())
  disconnectedAt DateTime?

  // Relations
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id])

  @@unique([gameId, playerId])
  @@index([gameId])
  @@index([playerId])
}

// GameClue - clues given during a game
model GameClue {
  id       String @id @default(uuid())
  gameId   String
  playerId String
  clue     String
  turnOrder Int

  createdAt DateTime @default(now())

  // Relations
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  player Player @relation(fields: [playerId], references: [id])

  @@index([gameId])
}

// GameVote - votes cast during a game
model GameVote {
  id         String @id @default(uuid())
  gameId     String
  casterId   String // Who cast the vote
  targetId   String // Who was voted for

  createdAt DateTime @default(now())

  // Relations
  game   Game   @relation(fields: [gameId], references: [id], onDelete: Cascade)
  caster Player @relation("VoteCaster", fields: [casterId], references: [id])
  target Player @relation("VoteTarget", fields: [targetId], references: [id])

  @@unique([gameId, casterId]) // One vote per player per game
  @@index([gameId])
}

// GameEvent - audit log of all game events
model GameEvent {
  id        String   @id @default(uuid())
  gameId    String
  eventType String // e.g., "player_joined", "game_started", "clue_submitted", "vote_cast"
  payload   Json? // Event-specific data

  createdAt DateTime @default(now())

  // Relations
  game Game @relation(fields: [gameId], references: [id], onDelete: Cascade)

  @@index([gameId])
  @@index([eventType])
  @@index([createdAt])
}

enum GameStatus {
  WAITING
  PLAYING
  VOTING
  GUESSING
  FINISHED
  CANCELLED
}
